\section{The Game Controller}

The game of Planes consists of a series of rounds played by the player against the computer. The player wins when it wins more rounds as the computer. This section describes the game controller that coordinates a single round. 

\subsection {Class Definition and Important Functions}

The game controller is implemented in the class PlaneRound. Its member variable are as follows:

\begin{lstlisting}
	//whether the computer or the player moves first
	bool m_isComputerFirst;
	//the  game statistics
	GameStatistics m_gameStats;
	
	//the player and computer's grid
	PlaneGrid* m_PlayerGrid;
	PlaneGrid* m_ComputerGrid;
	
	//the list of guesses for computer and player
	std::vector<GuessPoint> m_computerGuessList;
	std::vector<GuessPoint> m_playerGuessList;
	
	//the computer's strategy
	ComputerLogic* m_computerLogic;
\end{lstlisting}

It keeps track of who should make the first move (m\_isComputerFirst), of the score (m\_gameStats) and of the moves made (m\_computerGuessList, m\_playerGuessList). The decision making is left to m\_computerLogic. The two game boards are modelled by m\_PlayerGrid and m\_ComputerGrid.

The game controller reacts to external events and generates events for other parts of the software using Qt's signal and slots mechanism (\ref{Qt_Signals_Slots}). 

When the player has generated a move it reacts as follows:

\begin{lstlisting}

//treats a player's guess
void PlaneRound::receivedPlayerGuess(const GuessPoint& gp)
{
	//update the game statistics
	updateGameStats(gp, false);
	//add the player's guess to the list of guesses
	//assume that the guess is different from the other guesses
	m_playerGuessList.push_back(gp);
	
	//if the player is  first
	//run the computer's move
	if (!m_isComputerFirst)
	{
		GuessPoint gp = guessComputerMove();
		updateGameStats(gp, true);
		emit computerMoveGenerated(gp);
	}
	
	//play step is finished
	//verify if round is finished
	bool isComputerWinner = false;
	if (!isRoundEndet(isComputerWinner)) {
		playStep();
	} else {
		std::string text = "Round endet.";
		
		if (isComputerWinner) {
			text = text + " Computer is winner!";
			m_gameStats.updateWins(true);
			emit statsUpdated(m_gameStats);
		} else {
			text = text + " Player is winner!";
			m_gameStats.updateWins(false);
			emit statsUpdated(m_gameStats);
		}
		
		emit displayStatusMessage(text);
		emit roundEnds(!isComputerWinner);
	}
}

\end{lstlisting}

Given a guess by the player it updates the game statistics (how many hits, dead and misses were) and adds the guess to the list of player guesses. Depending on whether player moves first or computer moves first, it generates a computer move as well with the function guessComputerMove(). It then checks if there is a winner with the function isRoundEndet(). If so then it sends a signal called roundEnds(). When not it triggers the next step of the game with the function playStep().

Guessing of a computer move works as follows:

\begin{lstlisting}

GuessPoint PlaneRound::guessComputerMove()
{
	PlanesCommonTools::Coordinate2D qp;
	//use the computer strategy to get a move
	m_computerLogic->makeChoice(qp);
	
	//use the player grid to see the result of the grid
	GuessPoint::Type tp = m_PlayerGrid->getGuessResult(qp);
	GuessPoint gp(qp.x(), qp.y(), tp);
	
	//add the data to the computer strategy
	m_computerLogic->addData(gp);
	
	//update the computer guess list
	m_computerGuessList.push_back(gp);
	
	return gp;
}

\end{lstlisting}

The function makeChoice() of the ComputerLogic class is used which works as explained in section \ref{Computer_Strategy}. Then the PlayerGrid object is used to evaluate the guess. With the guess position and the guess result the member function addData() from ComputerLogic is called (\ref{Computer_Strategy}). Finally the computer's guess is added to the computer guess list. 

How is then the player guess generated ? This is generated by the player by clicking on a square of the game board in the GUI of the program. It comes as an external event to which the controller reacts with the function receivedPlayerGuess().

The function playStep() works as follows:

\begin{lstlisting}

//plays one computer move and one player move
void PlaneRound::playStep()
{
	//if computer is first guesses the computer move
	//and waits for the player's move
	if (m_isComputerFirst) {
		GuessPoint gp = guessComputerMove();
		updateGameStats(gp, true);
		emit computerMoveGenerated(gp);
		emit needPlayerGuess();
		emit displayStatusMessage("Player's turn");
	} else {
		//if player is first waits for the player's guess
		emit needPlayerGuess();
	}
}

\end{lstlisting}

If the computer moves first, the function guessComputerMove() is used to generate the computer move, then a reques for the player's guess is generated. If the the player moves first, the computer move is not generated anymore, as it will be generated later when the player's move arrives, in the function receivedPlayerGuess().

\subsection{C++ Concepts}

\subsubsection{The Qt Library}

\subsubsection{Qt Signals and Slots} \label {Qt_Signals_Slots}