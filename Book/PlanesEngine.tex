\documentclass{article}
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
    breaklines
}


\title{Application Logic for the Game of Planes}
\date{2017-06-09}
\author{Cristian Cucu}
\begin{document}
\maketitle
\newpage
\section{Introduction}
In the following I will explain the creation of the application's core which in our case is the logic of the game of planes. This part of the project should be independent of the graphical interface and should allow generic communication with it.
\section{The Game of Planes}
\marginpar{insert caption with the game board}
\section{Requirement Analysis}
Without thinking too much we notice that we need an object that describes a plane object which should at least contain information about the position of the plane on the game grid, the orientation of the plane, the shape of a plane. Since we have mentioned it above we would also need a game board/grid object. It should not be restricted to a specific geometry, should know where each plane is positioned and how many planes there are. Since the game is played against the computer there should be a kind of strategy object that decides the computer's next move.
\section{The Plane Object}
What defines a plane object ? Firstly the position of its head  (plane front) and its orientation. In order to define position we need a reference system in the plane grid. At the moment we do not bind explicitly the plane with a reference system or a game board. We assume that each plane exists somewhere in its own reference system and in its own rectangular grid. 

There can be 4 possible orientations which are declared in the Plane::Orientation enum.  

\marginpar{insert caption with 4 plane orientations}


\subsection{Class declaration}
\begin{lstlisting}
class Plane
{
public:
    enum Orientation {NorthSouth=0, SouthNorth=1, WestEast=2, EastWest=3};

private:
    //plane orientation
    Orientation m_orient;
    //coordinates of the position of the head of the plane
    int m_row, m_col;

public:
    //Various constructors
    Plane();
    Plane(int row, int col, Orientation orient);
    Plane(const QPoint &qp, Orientation orient);

    //setter and getters
    //gives the planes orientation
    Orientation orientation() const {return m_orient; }
    //gives the plane head's row and column
    int row() const { return m_row; }
    int col() const { return m_col;}
    //sets the plane head position
    void row(int row) { m_row = row; }
    void col(int col) { m_col = col; }
    void orientation(Orientation orient) { m_orient = orient; }
    //gives the coordinates of the plane head
    QPoint head() const { return QPoint(m_row,m_col); }

    //operators
    //compares two planes
    bool operator==(const Plane &pl1) const;
    //equals operator
    void operator=(const Plane &pl1);
    //translates a plane by a QPoint
    Plane operator+(const QPoint &qp);

    //geometrical transformations
    //clockwise rotation of planes
    void rotate();
    //translation with given offset in a grid with row and col rows and columns
    //if the future head position is not valid do not translate
    void translateWhenHeadPosValid(int offsetX, int offsetY, int row, int col);

    //other utility functions
    //tests whether a QPoint is a planes head
    bool isHead(const QPoint &qp) const { return qp == head(); }
    //checks if a certain point on the grid is on the plane
    bool containsPoint(const QPoint &qp) const;
    //returns whether a plane position is valid in a grid with row and col
    bool isPositionValid(int row, int col) const;
    //generates a random number from 0 and valmax-1
    static int generateRandomNumber(int valmax);
    //displays the plane
    QString toString() const;
};
\end{lstlisting}
\textbf{Simple concepts}: class definition, member variable declaration, classs method declaration, setters and getters\newline
\textbf{Advanced concepts}: constructor definition, static methods, enums, access types (private, int, protected), operators\newline
\marginpar{correctly define the above terms}
\marginpar{define styles for SimpleConcepts and AdvancedConcepts}
\subsection {Method Implementation}


\subsection {C++ Concepts}

\subsubsection {Class Definition}
Classes are the building blocks of C++ programs. They define properties of program objects as well as operations that can be performed on or with them. A class definition is a program block:
\begin{lstlisting}
class {
.......
};
\end{lstlisting}
Between the two parantheses  are included member variable declarations and method declarations. 

\subsubsection {Member Variable Declaration}
When object is seen as a box with pieces the member variables are the denomination of the placeholders for the pieces. The values of the member variables can be thought as descriptions of the object's state. Each member variable declaration consist of a type name and a variable name. The type name corresponds to the type of the variable, for example simple types as int, char, double or class types.

The listing below shows the member variable declarations in the Plane class.
\begin{lstlisting}
class {
    Orientation m_orient;
    int m_row, m_col;
};
\end{lstlisting}

\subsubsection {Class Method Declaration}
The methods of a class are declared in the corpus of the class and are analogous to function declarations in C: in their simple form they consist of a return type followed by a function name which is followed by function parameters listed in paranthesis after the function name.

\subsubsection {Setters and Getters}
Setters and getters are methods of a class that either change or read a member variable's value. Normally the member variables are not directly visible to the user of an object, but only through the means of class methods of which the simplest are the getters and the setters.

\begin{lstlisting}
    int row() const { return m_row; }
    int col() const { return m_col;}
    void row(int row) { m_row = row; }
    void col(int col) { m_col = col; }
\end{lstlisting}

\subsubsection {Constructor definition}
Constructors of a class are functions that are always called when the object is created. One of their task is the initialization of the member variables.

\begin{lstlisting}
    Plane();
    Plane(int row, int col, Orientation orient);
    Plane(const QPoint &qp, Orientation orient);
\end{lstlisting}

In the Plane class declaration we declare three constructors. The declaration is similar to a class method declaration except for they have no return types. The three constructors initialize the three member variables of the class Plane with the data that they receive as parameters. 

\subsubsection {Static methods}

Class methods are called with an object of their associated class. Static methods do not require an object of the associated class. The Plane class has only one such method which generates a random number.

\begin{lstlisting}
static int generateRandomNumber(int valmax);
\end{lstlisting}

\subsubsection {Enums}
\begin{lstlisting}
    enum Orientation {NorthSouth=0, SouthNorth=1, WestEast=2, EastWest=3};
\end{lstlisting}

Enums like the one defined above are basic types for which the variable values are listed at the time of type definition. In our case the new type is called Orientation and variables of this type can have the following values: NorthSouth, SouthNorth, WestEast, EastWest. For enums the associated variable values can be explicitly converted to int. As shown in the example above the conversion to int can be specified directly in the enum definition. Sometimes one desires to avoid such a conversion and to enforce a strict type checking when assigning enum variables to values. In this case one should use the 'enum class' instead of the simple enum.  

\subsubsection {Access types}
\subsubsection {Operators}

\end{document}