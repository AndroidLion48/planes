\section{The Computer Strategy}

\subsection{Data Structures}

The PlaneOrientationData structure keeps all the information required to justify the position and orientation of a specific plane. It works as follows: the Plane object is stored as a member variable m\_plane, if the position and orientation of the plane are not possible the member variable m\_discarded is set to true, the points on the grid that still need to be searched in order for the plane position and orientation to be completely proven are kept in the member variable m\_pointsNotTested. At the beginning all the points on the plane are in the list m\_pointsNotTested. As the game proceeds different points in m\_pointsNotTested will be tested and depending on what they reveal it can be that m\_discarded is set to true. Anyway after each guess of one point in m\_pointsNotTested the tested point is removed from the list. 

\begin{lstlisting}
struct PlaneOrientationData
{
	//the position of the plane
	Plane m_plane;
	
	//whether this orientation was discarded
	bool m_discarded;
	//points on this plane that were not tested
	//if m_discarded is false it means that all the
	//tested points were hits
	std::vector<PlanesCommonTools::Coordinate2D> m_pointsNotTested;
	
	//default constructor
	PlaneOrientationData();
	//another constructor
	PlaneOrientationData(const Plane& pl, bool isDiscarded);
	//copy constructor
	PlaneOrientationData(const PlaneOrientationData& pod);
	//equals operator
	void operator=(const PlaneOrientationData& pod);
	
	//update the info about this plane with another guess point
	//a guess point is a pair (position, guess result)
	void update(const GuessPoint& gp);
	//verifies if all the points in the current orientation were already checked
	bool areAllPointsChecked();
};

\end{lstlisting}

From the implementation file the following 3 functions are important: \begin{itemize}
	\item the constructor where a PlanePointIterator is used to initialize the m\_pointsNotTested member variable
	\item the update() function which receives a GuessPoint object, which is the result of a guess on the play board. The function updates m\_pointsNotTested and m\_discarded based on this new information.
	\item the function are areAllPointsChecked() which verifies if all points influencing the decision of the plain position and orientation being valid have been tested.
\end{itemize}

\begin{lstlisting}


//useful constructor
PlaneOrientationData::PlaneOrientationData(const Plane& pl, bool isDiscarded) :
	m_plane(pl),
	m_discarded(isDiscarded)
{
	PlanePointIterator ppi(m_plane);
	
	//all points of the plane besides the head are not tested yet
	ppi.next();

	while (ppi.hasNext())
	{
		m_pointsNotTested.push_back(ppi.next());
	}
}

void PlaneOrientationData::update(const GuessPoint &gp)
{
	//if plane is discarded return
	if (m_discarded)
		return;
	
	//find the guess point in the list of points not tested
	auto it = std::find(m_pointsNotTested.begin(), m_pointsNotTested.end(), PlanesCommonTools::Coordinate2D(gp.m_row, gp.m_col));
	
	//if point not found return
	if (it == m_pointsNotTested.end())
		return;
	
	//if point found
	//if dead and idx = 0 remove the head from the list of untested points
	if (gp.m_type == GuessPoint::Dead && it == m_pointsNotTested.begin())
	{
		m_pointsNotTested.erase(it);
		return;
	}
	
	//if miss or dead discard plane
	if (gp.m_type == GuessPoint::Miss || gp.m_type == GuessPoint::Dead)
		m_discarded = true;
	
	//if hit take point out of the list of points not tested
	if (gp.m_type == GuessPoint::Hit)
		m_pointsNotTested.erase(it);
}

//checks to see that all points on the plane were tested
bool PlaneOrientationData::areAllPointsChecked()
{
	return (m_pointsNotTested.empty());
}

\end{lstlisting}

In the game of Planes one should guess the position of the plane head and not the exact position and orientation of the corresponding plane. That is why a datastructure called HeadData.

\begin{lstlisting}
struct HeadData
{
	//size of the grid
	int m_row, m_col;
	//position of the head
	int m_headRow, m_headCol;
	//the correct plane orientation if decided
	int m_correctOrient;
	
	//statistics about the 4 positions with this head
	PlaneOrientationData m_options[4];
	
	HeadData(int row, int col, int headRow, int headCol);
	//update the current data with a guess
	//return true if a plane is confirmed
	bool update(const GuessPoint& gp);
};
\end{lstlisting}

The most important aspect of HeadData is that it contains 4 PlaneOrientationData structures, each for every possible orientation of a plane with a fixed head. Additional the size of the game board is saved, along with the plane head position. If there is enough data to be sure that the plane is in one of the 4 searched positions, m\_correctOrienta will be set to the index of the orientation in the array m\_options. The most important function is the function update() that receives a guess (which is a position on the game board together with a guess result: dead, hit, miss) and updates the knowledge about this plane head's position.

\subsection{C++ Concepts}

\subsubsection{Structs}
